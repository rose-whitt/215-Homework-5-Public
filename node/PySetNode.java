package main.rice.node;

import main.rice.obj.APyObj;
import main.rice.obj.PySetObj;
import main.rice.obj.PyTupleObj;

import java.util.*;

public class PySetNode<InnerType extends APyObj> extends AIterablePyNode<PySetObj<InnerType>, InnerType> {

    /**
     //     * The domain for exhaustive generation.
     //     */
    protected List<Number> exDomain;

    /**
     * The domain for random generation.
     */
    protected List<Number> ranDomain;

    /**
     * The RNG used for random generation.
     */
    protected Random rand = new Random();


    /**
     * PySetNode constructor. Will create a PySetNode encapsulating an innerNode.
     * @param innerNode : innerNode of type APyNode to be placed in PySetNode
     */
    public PySetNode(APyNode<InnerType> innerNode) {
        this.leftChild = innerNode;
    }



    /**
     * Generates all valid PySetObjs of type InnerType within the exhaustive domain.
     *
     * @return a set of PySetObjs of type InnerType comprising the exhaustive domain
     */
    public Set<PySetObj<InnerType>> genExVals() {
        // PRE PROCESS
        Set<PySetObj<InnerType>> retLi = new HashSet<>();

        // sort domain of lengths and get the largest length
        List<Number> exDomainCopy = this.getExDomain();
        List<Integer> exDomainInts = new ArrayList<>();
        for (Number len : exDomainCopy) {
            int temp = (int) len;
            exDomainInts.add(temp);
        }
        Collections.sort(exDomainInts);

        int lenSize = this.getExDomain().size();
        int maxVal = exDomainInts.get(lenSize - 1);

        // RECURSION
        Set<InnerType> childGenExVals = this.getLeftChild().genExVals();
        Set<Set<InnerType>> helper = genExValsSetRecHelper(maxVal, childGenExVals);

        // POST PROCESSING
        for (Set<InnerType> li : helper) {
            // remove sets of length not in the given domain
            if (this.getExDomain().contains(li.size())) {
                PySetObj liNode = new PySetObj(li);
                retLi.add(liNode);
            }
        }

        return retLi;

    }

    /**
     * Recursive helper for genExVals that generates all combinations of the inner type domain given the current value (length)
     * from the outer type domain
     * @param maxValue: current length from domain
     * @return: a set of sets where each set is of length maxValue and the appropriate combination of elements of type innerType
     */
    public Set<Set<InnerType>> genExValsSetRecHelper(int maxValue, Set<InnerType> childGenExVals) {
        // when length is zero
        if (maxValue == 0) {
            return new HashSet<>(Set.of(new HashSet<>()));
        }

        else {
            //      accumulation
            Set<Set<InnerType>> subsets = new HashSet<>(Set.of(new HashSet<>()));
            //      permutations, recursive call
            Set<Set<InnerType>> shortPerms = genExValsSetRecHelper(maxValue - 1, childGenExVals);

            // for each permutation of length - 1
            for (Set<InnerType> shortPerm : shortPerms) {
                // for each value to be added
                for (InnerType val : childGenExVals) {
                    // copy the previous permutation of lower length
                    Set<InnerType> temp = new HashSet<>(shortPerm);
                    // add your value to that permutation
                    temp.add(val);
                    // add the updated permutation to your subsets
                    subsets.add(temp);
                }
            }
            System.out.println("subset: " + subsets);
            return subsets;

        }
    }


    /**
     * Generate a random PySetObj containing random InnerTypes (generated by their
     *          own genRandVal()) and is of a randomly selected length from the random domain
     *
     * @return : a PySetObj of a random length randomly chosen from the random domain
     *              with values of type InnerType that were randomly generated from
     *              InnerType's domain
     */
    public PySetObj<InnerType> genRandVal() {
        // create list of inner type
        Set<InnerType> listInner = new HashSet<>();

        // get length randomly from random domain
        int len = (int) this.ranDomainChoice();


        while (listInner.size() != len) {
            // must take into account that sets do not allow duplicates
            if (!listInner.contains(this.getLeftChild().genRandVal())) {
                listInner.add(this.getLeftChild().genRandVal());
            }
        }

        // post processing
        // create PyListObj
        PySetObj<InnerType> randList = new PySetObj<>(listInner);

        return randList;
    }

}
